package renderer

import "core:math"

vec2 :: struct
{
  x, y : f32, 
}

vec3 :: struct
{
  x, y, z : f32,
}

//TODO: add functions to manipilate vectors 2D and 3D
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vector 3 functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_rotate_x :: proc (v : vec3, angle : f32) -> vec3
{
  rotated_vec : vec3 = {
    v.x,
    v.y * math.cos(angle) - v.z * math.sin(angle),
    v.y * math.sin(angle) + v.z * math.cos(angle),
  }

  return rotated_vec
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_rotate_y :: proc (v : vec3, angle : f32) -> vec3
{
  rotated_vec : vec3 = {
    v.x * math.cos(angle) - v.z * math.sin(angle),
    v.y, 
    v.x * math.sin(angle) + v.z * math.cos(angle),
  }

  return rotated_vec
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_rotate_z :: proc (v : vec3, angle : f32) -> vec3
{
  rotated_vec : vec3 = {
    v.x * math.cos(angle) - v.y * math.sin(angle),
    v.x * math.sin(angle) + v.y * math.cos(angle),
    v.z,
  }

  return rotated_vec
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_length :: proc(V : vec3) -> f32
{
  return math.sqrt_f32( ( V.x * V.x ) + ( V.y * V.y ) + ( V.z * V.z ) )
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_add :: proc(V1, V2 : vec3) -> vec3
{
  result : vec3 = { 
    V1.x + V2.x,
    V1.y + V2.y,
    V1.z + V2.z }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_sub :: proc(V1, V2 : vec3) -> vec3
{
  result : vec3 = {
    V1.x - V2.x,
    V1.y - V2.y,
    V1.z - V2.z }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_mul :: proc(V : vec3, FACTOR : f32) -> vec3
{
  result : vec3 = {
    V.x * FACTOR,
    V.y * FACTOR,
    V.z * FACTOR }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_div :: proc(V : vec3, FACTOR : f32) -> vec3
{
  result : vec3 = {
    V.x / FACTOR,
    V.y / FACTOR,
    V.z / FACTOR }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_cross :: proc(A, B : vec3) -> vec3
{
  result : vec3 = {
    ( A.y * B.z  ) - ( A.z * B.y ),
    ( A.z * B.x  ) - ( A.x * B.z ),
    ( A.x * B.y  ) - ( A.y * B.x ) }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec3_dot :: proc(A, B : vec3) -> f32
{
  return ( ( A.x * B.x ) + ( A.y * B.y ) + ( A.z * B.z) ) 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vector 2 functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec2_length :: proc(V : vec2) -> f32
{
  return math.sqrt_f32( ( V.x * V.x ) + ( V.y * V.y ) )
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec2_add :: proc(V1, V2 : vec2) -> vec2
{
  result : vec2 = { 
    V1.x + V2.x,
    V1.y + V2.y }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec2_sub :: proc(V1, V2 : vec2) -> vec2
{
  result : vec2 = {
    V1.x - V2.x,
    V1.y - V2.y }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec2_mul :: proc(V : vec2, FACTOR : f32) -> vec2
{
  result : vec2 = {
    V.x * FACTOR,
    V.y * FACTOR }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec2_div :: proc(V : vec2, FACTOR : f32) -> vec2
{
  result : vec2 = {
    V.x / FACTOR,
    V.y / FACTOR }
  return result
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vec2_dot :: proc(A, B : vec2) -> f32
{
  return ( ( A.x * B.x ) + ( A.y * B.y ) ) 
}
